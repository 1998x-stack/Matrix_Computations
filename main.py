structure = {
    "1._Preface_and_other": [
        "1.1_Preface_xi",
        "1.2_Global_References_xiii",
        "1.3_Other_Books_xv",
        "1.4_Useful_URLs_xix",
        "1.5_Common_Notation_xxi"
    ],
    "2._Chapters": [
        {
            "2.1_Matrix_Multiplication": [
                {
                    "2.1.1_Basic_Algorithms_and_Notation": [
                        "2.1.1.1_Matrix_Notation",
                        "2.1.1.2_Matrix_Operations",
                        "2.1.1.3_Vector_Notation",
                        "2.1.1.4_Vector_Operations",
                        "2.1.1.5_The_Computation_of_Dot_Products_and_Saxpys",
                        "2.1.1.6_Matrix-Vector_Multiplication_and_the_Gaxpy",
                        "2.1.1.7_Partitioning_a_Matrix_into_Rows_and_Columns",
                        "2.1.1.8_The_Colon_Notation",
                        "2.1.1.9_The_Outer_Product_Update",
                        "2.1.1.10_Matrix-Matrix_Multiplication",
                        "2.1.1.11_Scalar-Level_Specifications",
                        "2.1.1.12_A_Dot_Product_Formulation",
                        "2.1.1.13_A_Saxpy_Formulation",
                        "2.1.1.14_An_Outer_Product_Formulation",
                        "2.1.1.15_Flops"
                    ]
                }
            ]
        },
        {
            "2.2_Matrix_Analysis": [
                "2.2.1_Basic_Ideas_from_Linear_Algebra",
                "2.2.2_Vector_Norms",
                "2.2.3_Matrix_Norms",
                "2.2.4_The_Singular_Value_Decomposition",
                "2.2.5_Subspace_Metrics",
                "2.2.6_The_Sensitivity_of_Square_Systems",
                "2.2.7_Finite_Precision_Matrix_Computations"
            ]
        },
        {
            "2.3_General_Linear_Systems": [
                "2.3.1_Triangular_Systems",
                {
                    "2.3.2_The_LU_Factorization": [
                        "2.3.2.1_Recursive_Block_LU"
                    ]
                },
                "2.3.3_Roundoff_Error_in_Gaussian_Elimination",
                {
                    "2.3.4_Pivoting": [
                        "2.3.4.1_Rook_Pivoting"
                    ]
                },
                "2.3.5_Improving_and_Estimating_Accuracy",
                {
                    "2.3.6_Parallel_LU": [
                        "2.3.6.1_Tournament_Pivoting"
                    ]
                }
            ]
        },
        {
            "2.4_Special_Linear_Systems": [
                {
                    "2.4.1_Diagonal_Dominance_and_Symmetry": [
                        "2.4.1.1_Recursive_Block_Structures"
                    ]
                },
                "2.4.2_Positive_Definite_Systems",
                {
                    "2.4.3_Banded_Systems": [
                        "2.4.3.1_Band_Matrix_Inverse_Properties"
                    ]
                },
                "2.4.4_Symmetric_Indefinite_Systems",
                {
                    "2.4.5_Block_Tridiagonal_Systems": [
                        "2.4.5.1_Divide-and-Conquer_Strategies_for_Block_Tridiagonal_Systems"
                    ]
                },
                "2.4.6_Vandermonde_Systems",
                "2.4.7_Classical_Methods_for_Toeplitz_Systems",
                "2.4.8_Circulant_and_Discrete_Poisson_Systems"
            ]
        },
        {
            "2.5_Orthogonalization_and_Least_Squares": [
                "2.5.1_Householder_and_Givens_Transformations",
                "2.5.2_The_QR_Factorization",
                {
                    "2.5.3_The_Full-Rank_Least_Squares_Problem": [
                        "2.5.3.1_Cross_Product_and_Various_Point/Plane_Least_Squares_Problems"
                    ]
                },
                "2.5.4_Other_Orthogonal_Factorizations",
                "2.5.5_The_Rank-Deficient_Least_Squares_Problem",
                "2.5.6_Square_and_Underdetermined_Systems"
            ]
        },
        {
            "2.6_Modified_Least_Squares_Problems_and_Methods": [
                "2.6.1_Weighting_and_Regularization",
                "2.6.2_Constrained_Least_Squares",
                "2.6.3_Total_Least_Squares",
                "2.6.4_Subspace_Computations_with_the_SVD",
                "2.6.5_Updating_Matrix_Factorizations"
            ]
        },
        {
            "2.7_Unsymmetric_Eigenvalue_Problems": [
                "2.7.1_Properties_and_Decompositions",
                "2.7.2_Perturbation_Theory",
                "2.7.3_Power_Iterations",
                "2.7.4_The_Hessenberg_and_Real_Schur_Forms",
                "2.7.5_The_Practical_QR_Algorithm",
                "2.7.6_Invariant_Subspace_Computations",
                {
                    "2.7.7_The_Generalized_Eigenvalue_Problem": [
                        "2.7.7.1_Polynomial_Eigenvalue_Problem"
                    ]
                },
                "2.7.8_Hamiltonian_and_Product_Eigenvalue_Problems",
                "2.7.9_Pseudospectra"
            ]
        },
        {
            "2.8_Symmetric_Eigenvalue_Problems": [
                "2.8.1_Properties_and_Decompositions",
                "2.8.2_Power_Iterations",
                "2.8.3_The_Symmetric_QR_Algorithm",
                "2.8.4_More_Methods_for_Tridiagonal_Problems",
                "2.8.5_Jacobi_Methods",
                "2.8.6_Computing_the_SVD",
                {
                    "2.8.7_Generalized_Eigenvalue_Problems_with_Symmetry": [
                        "2.8.7.1_Structured_Quadratic_Eigenvalue_Problem"
                    ]
                }
            ]
        },
        {
            "2.9_Functions_of_Matrices": [
                "2.9.1_Eigenvalue_Methods",
                "2.9.2_Approximation_Methods",
                "2.9.3_The_Matrix_Exponential",
                "2.9.4_The_Sign_Square_Root_and_Log_of_a_Matrix"
            ]
        },
        {
            "2.10_Large_Sparse_Eigenvalue_Problems": [
                "2.10.1_The_Symmetric_Lanczos_Process",
                "2.10.2_Lanczos_Quadrature_and_Approximation",
                "2.10.3_Practical_Lanczos_Procedures",
                "2.10.4_Large_Sparse_SVD_Frameworks",
                "2.10.5_Krylov_Methods_for_Unsymmetric_Problems",
                "2.10.6_Jacobi-Davidson_and_Related_Methods"
            ]
        },
        {
            "2.11_Large_Sparse_Linear_System_Problems": [
                "2.11.1_Direct_Methods",
                "2.11.2_The_Classical_Iterations",
                "2.11.3_The_Conjugate_Gradient_Method",
                "2.11.4_Other_Krylov_Methods",
                "2.11.5_Preconditioning",
                "2.11.6_The_Multigrid_Framework"
            ]
        },
        {
            "2.12_Special_Topics": [
                "2.12.1_Linear_Systems_with_Displacement_Structure",
                "2.12.2_Structured-Rank_Problems",
                "2.12.3_Kronecker_Product_Computations",
                "2.12.4_Tensor_Unfoldings_and_Contractions",
                "2.12.5_Tensor_Decompositions_and_Iterations"
            ]
        }
    ],
    "3._Index": [
        "3.1_Index_747"
    ]
}


import os
from typing import Dict, Any

def create_directories_and_files(
        base_path: str, 
        structure: Dict[str, Any], 
        readme_file, 
        parent_path: str = "", 
        level: int = 1
    ):
    heading = "#" * level

    for key, value in structure.items():
        current_path = os.path.join(base_path, key.replace(" ", "_").replace("/", "_").replace("-", "_"))

        # 创建目录
        os.makedirs(current_path, exist_ok=True)

        # 在README中添加章节标题
        if parent_path:
            readme_file.write(f"{heading} {parent_path}/{key}\n\n")
        else:
            readme_file.write(f"{heading} {key}\n\n")

        # 递归调用创建子目录和文件
        if isinstance(value, dict) and value:
            create_directories_and_files(
                current_path, 
                value, 
                readme_file, 
                parent_path + "/" + key if parent_path else key, 
                level + 1
            )
        elif isinstance(value, list) and value:
            for idx, item in enumerate(value):
                if isinstance(item, dict) and item:
                    create_directories_and_files(
                        current_path, 
                        item, 
                        readme_file, 
                        parent_path + "/" + key if parent_path else key, 
                        level + 1
                    )
                else:
                    item = f"{idx:02d}_{item}"
                    file_name = item.replace(" ", "_").replace("/", "_").replace("-", "_") + ".py"
                    file_path = os.path.join(current_path, file_name)
                    with open(file_path, 'w', encoding='utf-8') as file:
                        file.write(f"# {item}\n\n")
                        file.write(f'"""\n\nLecture: {parent_path}/{key}\nContent: {item}\n\n"""\n\n')

                    # 在README中添加文件链接
                    item_clean = item.replace(" ", "_").replace("/", "_").replace("-", "_")
                    parent_clean = parent_path.replace(" ", "_").replace("/", "_").replace("-", "_")
                    key_clean = key.replace(" ", "_").replace("/", "_").replace("-", "_")
                    readme_file.write(f"- [{item}](./{parent_clean}/{key_clean}/{item_clean}.py)\n")
                    
                    
                    file_name = item.replace(" ", "_").replace("/", "_").replace("-", "_") + ".md"
                    file_path = os.path.join(current_path, file_name)
                    with open(file_path, 'w', encoding='utf-8') as file:
                        file.write(f"# {item}\n\n")
                        file.write(f'"""\n\nLecture: {parent_path}/{key}\nContent: {item}\n\n"""\n\n')

                    # 在README中添加文件链接
                    item_clean = item.replace(" ", "_").replace("/", "_").replace("-", "_")
                    parent_clean = parent_path.replace(" ", "_").replace("/", "_").replace("-", "_")
                    key_clean = key.replace(" ", "_").replace("/", "_").replace("-", "_")
                    readme_file.write(f"- [{item}](./{parent_clean}/{key_clean}/{item_clean}.md)\n")
        else:
            # 创建文件并写入初始内容
            file_name = key.replace(" ", "_").replace("/", "_").replace("-", "_") + ".py"
            file_path = os.path.join(current_path, file_name)
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(f"# {key}\n\n")
                file.write(f'"""\n\nLecture: {parent_path}/{key}\nContent: {key}\n\n"""\n\n')

            # 在README中添加文件链接
            parent_clean = parent_path.replace(" ", "_").replace("/", "_").replace("-", "_")
            key_clean = key.replace(" ", "_").replace("/", "_").replace("-", "_")
            readme_file.write(f"- [{key}](./{parent_clean}/{key_clean}/{file_name})\n")
            
            
            file_name = key.replace(" ", "_").replace("/", "_").replace("-", "_") + ".md"
            file_path = os.path.join(current_path, file_name)
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(f"# {key}\n\n")
                file.write(f'"""\n\nLecture: {parent_path}/{key}\nContent: {key}\n\n"""\n\n')

            # 在README中添加文件链接
            parent_clean = parent_path.replace(" ", "_").replace("/", "_").replace("-", "_")
            key_clean = key.replace(" ", "_").replace("/", "_").replace("-", "_")
            readme_file.write(f"- [{key}](./{parent_clean}/{key_clean}/{file_name})\n")

        # 添加空行以分隔不同的章节
        readme_file.write("\n")

def main():
    root_dir = './'
    # 创建根目录
    os.makedirs(root_dir, exist_ok=True)

    # 创建 README.md 文件
    with open(os.path.join(root_dir, "README.md"), 'w', encoding='utf-8') as readme_file:
        readme_file.write("# Matrix Computation\n\n")
        readme_file.write("这是一个关于Matrix Computation的目录结构。\n\n")
        create_directories_and_files(root_dir, structure, readme_file)

    print("目录和文件结构已生成，并创建 README.md 文件。")

if __name__ == "__main__":
    main()